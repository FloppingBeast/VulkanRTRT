/*********************************************************************
 * file:   raytrace.rgen
 * author: lawrence.winters (lawrence.winters@digipen.edu)
 * date:   July 2, 2024
 * Copyright ï¿½ 2024 DigiPen (USA) Corporation.
 *
 * brief: Body for generating a ray in this file
 *********************************************************************/

#version 460
#extension GL_EXT_ray_tracing : require
#extension GL_EXT_scalar_block_layout : enable
#extension GL_EXT_shader_explicit_arithmetic_types_int64  : require
#extension GL_GOOGLE_include_directive : enable
#extension GL_EXT_buffer_reference2 : require
#extension GL_EXT_nonuniform_qualifier : enable

#include "shared_structs.h"
#include "rng.glsl"

#define pi (3.141592)
#define pi2 (2.0*pi)

// The ray payload; structure is defined in shared_structs.h;
// Attached to a ray, and used to communicate between shader stages.
layout(location=0) rayPayloadEXT RayPayload payload;

// Push constant for ray tracing; structure is defined in shared_structs.h;
// Filled in by application, and pushed to shaders as part of the pipeline invocation
layout(push_constant) uniform _PushConstantRay { PushConstantRay pcRay; };

// Ray tracing descriptor set: 0:acceleration structure, and 1: color output image
layout(set=0, binding=0) uniform accelerationStructureEXT topLevelAS;
layout(set=0, binding=1, rgba32f) uniform image2D colCurr; // Output image: m_rtColCurrBuffer
layout(set=0, binding=2, rgba32f) uniform image2D colPrev; // Output image: m_rtColPrevBuffer
layout(set=0, binding=3, rgba32f) uniform image2D kdCurr; // Surface store: m_rtKdCurrBuffer
layout(set=0, binding=4, rgba32f) uniform image2D kdPrev; // Surface store: m_rtKdPrevBuffer
layout(set=0, binding=5, rgba32f) uniform image2D ndCurr; // Depth buffer: m_rtNdCurrBuffer
layout(set=0, binding=6, rgba32f) uniform image2D ndPrev; // Depth buffer: m_rtNdPrevBuffer

// Object model descriptor set: 0: matrices, 1:object buffer addresses, 2: texture list
layout(set=1, binding=0) uniform _MatrixUniforms { MatrixUniforms mats; };
layout(set=1, binding=1, scalar) buffer ObjDesc_ { ObjDesc i[]; } objDesc;
layout(set=1, binding=2) uniform sampler2D textureSamplers[];

// Object buffered data; dereferenced from ObjDesc addresses;  Must be global
layout(buffer_reference, scalar) buffer Vertices {Vertex v[]; }; // Position, normals, ..
layout(buffer_reference, scalar) buffer Indices {ivec3 i[]; }; // Triangle indices
layout(buffer_reference, scalar) buffer Materials {Material m[]; }; // Array of all materials
layout(buffer_reference, scalar) buffer MatIndices {int i[]; }; // Material ID for each triangle

// @@ Raycasting: Write EvalBrdf -- The BRDF lighting calculation (DONE)

// Uses GGX to solve for G factor
float GFactor(vec3 v, vec3 m, vec3 N, float ag2)
{
  float vdotN = dot(v, N);

  if (vdotN > 1.0f)
  {
    return 1.0f;
  }
  else if ((dot(v, m) / vdotN) <= 0.0f)
  {
    return 0.0f;
  }
  else
  {
    float tanv = sqrt(1.0f - (vdotN * vdotN)) / vdotN;
    
    return ( 2.0f / sqrt(1.0f + (ag2 * (tanv * tanv))) );
  }
}

// Uses GGX to solve for D factor
float DFactor(vec3 m, vec3 N, float ag2)
{
  float mdotN = dot(m, N);

  if (mdotN <= 0.0f)
  {
    return 0.0f;
  }
  else
  {
    float tanm = sqrt(1.0f - (mdotN * mdotN)) / mdotN;
    float tanm2 = tanm * tanm;
    
    return ( ag2 / (pi * pow(mdotN, 4) * pow(ag2 + tanm2, 2)) );
  }
}

// Calculates BRDF lighting for specular effects
vec3 EvalBrdf(vec3 N, vec3 L, vec3 V, Material mat) 
{
  vec3 diffusePortion = mat.diffuse / pi;

  vec3 BRDF = vec3(0.0f);

  if (pcRay.BRDF)
  {
    vec3 H = normalize(L + V);

    float LdotH = dot(L, H);

    float LdotN = dot(L, N);
    float VdotN = dot(V, N);

    float ag = sqrt(2.0f / (mat.shininess + 2.0f));
    float ag2 = ag * ag;

    float D = DFactor(H, N, ag2);

    vec3 F = mat.specular + (1.0f - mat.specular) * pow(1.0f - abs(LdotH), 5);

    float G = GFactor(L, H, N, ag2) * GFactor(V, H, N, ag2);

    vec3 FGD = (D * G * F) / (4.0f * abs(LdotN) * abs(VdotN));

    BRDF = FGD;
  }

  return diffusePortion + BRDF;
}

// @@ Pathtracing: Write SampleBrdf, PdfBrdf, ...(DONE)

vec3 SampleLobe(vec3 A, float cosAngle, float phi)
{
  float s = sqrt(1.0f - (cosAngle * cosAngle));

  // Create vector K centered around Z-axis and rotate to A-axis
  vec3 K = vec3(s * cos(phi), s * sin(phi), cosAngle);

  if (abs(A.z - 1.0f) < 0.001f) return K;
  if (abs(A.z + 1.0f) < 0.001f) return vec3(K.x, -K.y, -K.z);

  vec3 B = normalize(vec3(-A.y, A.x, 0.0f));
  vec3 C = cross(A, B);

  return (K.x * B) + (K.y * C) + (K.z * A); 
}

vec3 SampleBrdf(inout uint seed, in vec3 N) 
{
  return SampleLobe(N, sqrt(rnd(seed)), pi2 * rnd(seed));
}

float PdfBrdf(vec3 N, vec3 Wi)
{
  float numerator = dot(N, Wi);

  return abs(numerator) / pi;
}

// Given a ray's payload indicating a triangle has been hit
// (payload.instanceIndex, and payload.primitiveIndex),
// lookup/calculate the material, texture and normal at the hit point
// from the three vertices of the hit triangle.
void GetHitObjectData(out Material mat, out vec3 nrm)
{
    // Object data (containing 4 device addresses)
    ObjDesc    objResources = objDesc.i[payload.instanceIndex];
    
    // Dereference the object's 4 device addresses
    Vertices   vertices    = Vertices(objResources.vertexAddress);
    Indices    indices     = Indices(objResources.indexAddress);
    Materials  materials   = Materials(objResources.materialAddress);
    MatIndices matIndices  = MatIndices(objResources.materialIndexAddress);
  
    // Use gl_PrimitiveID to access the triangle's vertices and material
    ivec3 ind    = indices.i[payload.primitiveIndex]; // The triangle hit
    int matIdx   = matIndices.i[payload.primitiveIndex]; // The triangles material index
    mat = materials.m[matIdx]; // The triangles material

    // Vertex of the triangle (Vertex has pos, nrm, tex)
    Vertex v0 = vertices.v[ind.x];
    Vertex v1 = vertices.v[ind.y];
    Vertex v2 = vertices.v[ind.z];

    // Compute normal at hit position using the provided barycentric coordinates.
    const vec3 bc = payload.bc; // The barycentric coordinates of the hit point
    nrm  = bc.x*v0.nrm + bc.y*v1.nrm + bc.z*v2.nrm; // Normal = combo of three vertex normals

    // If the material has a texture, read texture and use as the
    // point's diffuse color.
    if (mat.textureId >= 0) {
        vec2 uv =  bc.x*v0.texCoord + bc.y*v1.texCoord + bc.z*v2.texCoord;
        uint txtId = objResources.txtOffset + mat.textureId; // tex coord from three vertices
        mat.diffuse = texture(textureSamplers[(txtId)], uv).xyz; }
}

// Helper function for getting the selective weight at a pixel (i,j) for History Tracking
float SelectiveWeight(ivec2 iloc, float bWeight, int i, int j, float firstDepth, vec3 firstNrm)
{
  vec4 prevNd = imageLoad(ndPrev, iloc + ivec2(0,0));
  vec3 prevNrm = prevNd.xyz;
  float prevDepth = prevNd.w;

  float dWeight = 0;
  if (abs(firstDepth - prevDepth) < pcRay.dThresh) dWeight = 1.0f;

  float nWeight = 0;
  if (dot(firstNrm, prevNrm) > pcRay.nThresh) nWeight = 1.0f;

  return bWeight * dWeight * nWeight;
}

vec4 PreviousFrameAccumumlation(vec2 screen, inout bool invalidHistory, float firstDepth, vec3 firstNrm)
{
  vec2 floc = screen * gl_LaunchSizeEXT.xy - vec2(0.5);
  vec2 offset = fract(floc); // 0 to 1 offset between 4 neighbors
  ivec2 iloc = ivec2(floc); // (0,0) corner of the 4 neighbors

  vec4 p_0_0 = imageLoad(colPrev, iloc+ivec2(0,0));
  vec4 p_1_0 = imageLoad(colPrev, iloc+ivec2(1,0));
  vec4 p_0_1 = imageLoad(colPrev, iloc+ivec2(0,1));
  vec4 p_1_1 = imageLoad(colPrev, iloc+ivec2(1,1));

   
  float b_0_0 = (1 - offset.x) * (1 - offset.y);
  float w_0_0 = SelectiveWeight(iloc, b_0_0, 0, 0, firstDepth, firstNrm);

  float b_1_0 = (offset.x) * (1 - offset.y);
  float w_1_0 = SelectiveWeight(iloc, b_1_0, 1, 0, firstDepth, firstNrm);

  float b_0_1 = (1 - offset.x) * (offset.y);
  float w_0_1 = SelectiveWeight(iloc, b_0_1, 0, 1, firstDepth, firstNrm);

  float b_1_1 = (offset.x) * (offset.y);
  float w_1_1 = SelectiveWeight(iloc, b_1_1, 1, 1, firstDepth, firstNrm);

  float totalWeight = w_0_0 + w_1_0 + w_0_1 + w_1_1;

  if (totalWeight <= 0.000001)
  {
    invalidHistory = true;

    return vec4(0);
  }
  vec4 P = ( (w_0_0 * p_0_0) + (w_1_0 * p_1_0) + (w_0_1 * p_0_1) + (w_1_1 * p_1_1) ) / (w_0_0 + w_1_0 + w_0_1 + w_1_1);

  return P;
}

// MAIN BODY
void main() 
{   
    // This shader's invocation is for the pixel indicated by
    // gl_LaunchIDEXT. Calculate that pixel's center (in NDC) and
    // convert to a ray in world coordinates.
    const vec2 pixelCenter = vec2(gl_LaunchIDEXT.xy) + vec2(0.5);
    vec2 pixelNDC = pixelCenter/vec2(gl_LaunchSizeEXT.xy)*2.0 - 1.0;
 
    vec3 eyeW    = (mats.viewInverse * vec4(0, 0, 0, 1)).xyz;
    vec4 pixelH = mats.viewInverse * mats.projInverse * vec4(pixelNDC.x, pixelNDC.y, 1, 1);
    vec3 pixelW = pixelH.xyz / pixelH.w;

    // This pixel's ray:
    vec3 rayOrigin    = eyeW;
    vec3 rayDirection = normalize(pixelW - eyeW);

    // The ray-casting / path-tracing block/loop will store the
    // pixel's calculated color in C.
    vec3 C = vec3(0,0,0);
    // The path tracing algorithm will accumulate a product of f/p weights in W.
    vec3 W = vec3(1,1,1);
    
    // @@ Pathtracing: Initialize random pixel seed *very* carefully! (See notes.) (DONE)
    payload.seed = tea((gl_LaunchIDEXT.y * gl_LaunchSizeEXT.x) + gl_LaunchIDEXT.x, pcRay.frameSeed);

    // @@ History: Initialize first-hit data
    bool firstHit = false;
    vec3 firstPos = vec3(0);
    float firstDepth = 0;
    vec3 firstNrm = vec3(0);
    vec3 firstKd = vec3(0);

    bool invalidHistory = false; // Use for tracking failure cases of history
    
    // Monte-Carlo loop
    for (int i = 0; i < pcRay.depth; ++i)
    {
      payload.hit = false;
      // Fire the ray;  hit or miss shaders will be invoked, passing results back in the payload
      traceRayEXT(topLevelAS,           // acceleration structure
                  gl_RayFlagsOpaqueEXT, // rayFlags
                  0xFF,                 // cullMask
                  0,                    // sbtRecordOffset for the hitgroups
                  0,                    // sbtRecordStride for the hitgroups
                  0,                    // missIndex
                  rayOrigin,            // ray origin
                  0.001,                // ray min range
                  rayDirection,         // ray direction
                  10000.0,              // ray max range
                  0                     // payload (location = 0)
                  );

      // If nothing was hit
      if (!payload.hit) 
      {
          // @@ History: if (i==0) record that a first-hit did not occur (DONE)
          if (i == 0 && pcRay.history) firstHit = payload.hit;

          break;
      }
      
      // If something was hit, find the object data.
      Material mat;
      vec3 nrm;
      GetHitObjectData(mat, nrm);
      
      // @@ History: if (i==0) record first-hit stuff.
      if (i == 0 && pcRay.history)
      {
        firstHit = payload.hit;
        firstPos = payload.hitPos;

        firstDepth = payload.hitDist;
        firstNrm = nrm;
        firstKd = mat.diffuse;

        if (isnan(firstDepth) || isinf(firstDepth)) firstDepth = 0;
        if (any(isnan(firstNrm)) || any(isinf(firstNrm))) firstNrm = vec3(0);
        if (any(isnan(firstKd)) || any(isinf(firstKd))) firstKd = vec3(0);
         
        // Go ahead and store surface color, nrm, and depth
        imageStore(kdCurr, ivec2(gl_LaunchIDEXT.xy), vec4(firstKd,0));
        imageStore(ndCurr, ivec2(gl_LaunchIDEXT.xy), vec4(firstNrm,firstDepth));
      }
      
      // If the material indicates the hit triangle is a light, output (via C):
      // @@ RayCasting: the light's emission value possibly scaled by an exposure value (DONE)
      // @@ Pathtracing: the light's emission value times all the paths BRDFs (in W) (DONE)
      // @@ Then (in either case) break from MC loop.
      if (dot(mat.emission, mat.emission) > 0.0) 
      {
          C += (mat.emission * W); //* pcRay.exposure;
          break; 
      }

      // @@ Explicit light connection (if implemented) goes here

      // @@ Pathtracing:  Accumulate product of lighting calculations into W. (DONE)
      //   Sample random direction Wi = ?
      //   Calculate f = (N dot Wi) * EvalBRDF(N, L, V, mat)
      //   Calculate p = ?
      //   Accumulate f/p into W;  No C += here anymore.
      //   Setup for next loop iteration.
      vec3 P = payload.hitPos; // current hit point
      vec3 N = normalize(nrm); // Normal
      vec3 Wi = SampleBrdf(payload.seed, N); // Importance sample output direction
      vec3 Wo = -rayDirection;

      vec3 f = dot(N, Wi) * EvalBrdf(N, Wi, Wo, mat);

      float p = PdfBrdf(N, Wi) * pcRay.russianRoulette; // Probability (float) of above sample of Wi

      if (p < 0.000001f) break; // Comparison with epsilon
      W *= f/p;  // Monte-Carlo estimator

      rayOrigin = P;
      rayDirection = Wi;
    } // End of Monte-Carlo block/loop
     

    // @@ History: Accumulate C with <whatever> and write to the output pixel
    if (pcRay.history)
    {
      // STEP 1: Back-project the current frame's world position into the previous frame
      vec4 screenH = (mats.priorViewProj * vec4(firstPos, 1.0)); // Project to prev buffers

      // FAILURE CASE 1/2
      if (!firstHit)
      {
        invalidHistory = true;
      }

      vec2 screen = vec2(0);
      if (!invalidHistory)
      {
        screen = ((screenH.xy / screenH.w) + vec2(1.0)) / 2.0; // H-division and map to [0,1]
        if ((screen.x < 0.0f || screen.x > 1.0f) || (screen.y < 0.0f || screen.y > 1.0f))
        {
          invalidHistory = true;
        }
      }

      // STEP 2: Calculate the previous frame's accumulation
      vec4 P = vec4(0);
      if (!invalidHistory) P = PreviousFrameAccumumlation(screen, invalidHistory, firstDepth, firstNrm);

      vec3 oldAve = vec3(0.5);
      float oldN = 0;

      // FAILURE CASE 3
      // if P finds no valid pixels to average
      if (!invalidHistory)
      {
        oldAve = P.xyz;
        oldN = P.w;
      }
       
      float newN = oldN + 1;
      vec3 newAve = oldAve +  (C - oldAve) / newN;

      if (any(isnan(newAve)) || any(isinf(newAve)))
      {
        newAve = vec3(0.0);
        newN = 1.0f;
      }
      imageStore(colCurr, ivec2(gl_LaunchIDEXT.xy), vec4(newAve, newN));
    }
    else
    {
      if (pcRay.clear)
      {
       imageStore(colCurr, ivec2(gl_LaunchIDEXT.xy), vec4(C,1.0));
      }
      else if (!pcRay.clear && pcRay.accumulate)
      {
        vec4 old = imageLoad(colCurr, ivec2(gl_LaunchIDEXT.xy));
        vec3 Ave = old.xyz;
        float num = old.w;

        Ave += ((C - Ave) / (num + 1));

        imageStore(colCurr, ivec2(gl_LaunchIDEXT.xy), vec4(Ave, num + 1));
      }
    }

}

//  LocalWords:  Pathtracing Raycasting
